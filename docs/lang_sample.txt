package mypkg
import math
# imported procs are either accesible via full name: math.abs, or via dot-notation on variable/literal: (-1).abs

# integer type is signed 32-bit by default, signed 64-bit otherwise
const a = 0x33
const b: byte = 255
public const c = "a string"
var d = a + b
const e = c + " another string"

alias sqrt = math.sqrt

alias i32 = int

type Id = long

# all 'proc' arguments are read-only except for 'var'.
# dot-notation dispatches on exact type match by the first argument.
# There can not be 'var' and non-var procs with same name. 

proc abs(i: int): int
    return i < 0 ? -i : i
end

# Error!
proc abs(i: var int): int
end

# ok
proc abs_var(i: var int): int
end

proc abs(i: long): long
    return i < 0 ? -i : i
end

# multiple return values
proc mod_div(a, b: int): (d, rem: int)
    # either
    d = a / b
    rem = a % b
    # or
    return (a/b, a%b)
end

proc test_mod_div()
    var d, r:int
    (d,r) = mod_div(3,2)
end

# generic, works only with reference types (objects/interfaces)
proc<Obj> weak(o: Obj?): weak<Obj>
    return o
end

# lambdas
proc m()
    var b = 3
    var obj = Object.new()

    var a = proc[obj = weak(obj), b](a: int)
        retain(obj)
            obj.do_smth(b)
        on_null
            # null
        end_retain
    end
end


# enums, string, integer mappings, attributes

type StrAnn = struct
    var str, alt1, alt2: string
end_struct

type DayOfWeek = enum<int>
    @StrAnn{str = literal(Monday), alt1 = "mon", alt2 = "monday"}
    Monday = 1,
    Tuesday,
    Wednesday = 3
end_enum

const Monday = cast<int>(DayOfWeek.Monday)
const MondayAlt2 = DayOfWeek.Monday.@StrAnn.alt1

# probably, will not be supported because of annotations:
type ShortDayOfWeek = enum<string>
    Monday = "mon",
    Tuesday = "tue",
    Wednesday = "wed"
end_enum

const Wed = cast<string>(ShortDayOfWeek.Wednesday)


# bitsets
# second argument ('u8') is optional
type WorkingDaysMask = bitset<DayOfWeek, u8>
const working_days = WorkingDaysMask(Monday, Wednesday)


# arrays, copied on assignment, always have length accessible as .len property
# dynamic array, uses heap
var arr: array<int>

# static array
const arr2 = [1,2,3]

# union type? can be implemented via properties

# variant type? can be implemented via interfaces

# 'struct' is a value type, directly mappable to C struct.
# Compiler generates default constructor to set field values, then calls _init if it is defined.
# Compiler generates default destructor to clear referenced objects, _finalize is called before calling generated destructor.
# Either a) default constructor then _copy is called on assignment if defined, b) fields copied by assignment.
type St = struct
    var c: int
    property y:int, set(c), get(c)
end_struct

# optional copy constructor
proc _copy(dest: var St, src: var St)
    dest.c = src.c
end

# optional default constructor for St
proc _init(s: var St)

end

# optional destructor for struct
proc _finalize(s: var St)
    s.c = 0xFEADFEAD
end


# 'object' is a referenced type with RTTI, interfaces etc.
# Compiler generates default constructor to set field values, then calls _init if it is defined.
# Compiler generates default destructor to clear referenced objects, _finalize is called before calling generated destructor.
type Obj = object
    var f: u32 = 3
    property flags:u32, set(f), get(f)
end_object

# optional default constructor for Obj
proc _init(o: Obj)

end

# optional destructor for object
proc _finalize(o: Obj)
    o.f = 0xFFFFFFFF
end


# Class is a reference type which is not Object instance, passed as raw pointer, lives in the static data,
# provides access to attributes, new instance method.

# Obj.new() -- shorthand for Obj._class.new()
var o = Obj.new()
var cls = o._class
var new_inst = cls.new()

# Object cloning is implemented via cls.new() + implementing Copy interface with 'copy_from' method.

# 'Object' is a universal 'base' class/interface, it has only _class property available.
# upcasting is possible only to nullable references.

var o: Object = Obj.new()
# ok
var obj = cast<Obj?>(o)
# error!
var obj = cast<Obj>(o)
# error! cannot access nullable references
obj._class.new()
# ok
retain(obj)
    obj._class.new()
end_retain
retain(obj)
    obj._class.new()
on_null
    println("cannot upcast")
end_retain

# interfaces
type Object = interface
    # read-only property
    property _class: Class, get
end_interface

type Copy = interface<O>
    proc copy_from(dest: O, src: O)
end_interface

# TODO delegations, attributes, retrospection